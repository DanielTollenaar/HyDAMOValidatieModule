{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome HyDAMO Validation The HyDAMO Validation Module is used to validate HyDAMO data.","title":"Home"},{"location":"#welcome-hydamo-validation","text":"The HyDAMO Validation Module is used to validate HyDAMO data.","title":"Welcome HyDAMO Validation"},{"location":"guides/contribute/","text":"Contribute For doing contributions you: have your own GitHub account work with GitHub Desktop or work-round with Git can work with GeoPandas and Pytest We are very happy with contributions that are: written similar to existing code (e.g. use of GeoPandas) provided with docstrings so it can be documented tested with Pytest You can make a contribution in the following steps: Development installation Fork and clone and install a copy Add and test new code Commit your copy and request a merge The remainder of this guide explains how to do it. Dev installation Setup environment Use the env/dev_environment.yml in the repository to create the conda environment validatietool with all required packages conda env create -f dev_environment.yml After installation you can activate your environment in command prompt Fork repo Fork the respository to your own GitHub account: Click fork in the upper-right of the rository. Select your own github account The repository is now available on your own github account: Clone repo Now clone your fork to your local drive. We do this with GitHub Desktop . After installation and authentication you can get a local copy by: Add and Clone repository... in the top-left corner Find your fork and clone it to an empty directory on your local drive Press clone` Verify if the repository is on your local drive. Install copy Install the module in the activated validatietool environment in develop-mode: pip install -e . Now you're good to go! Improve code Imagine we want to be able to multiply an HyDAMO attribute by a constant value or a value in an other attribute. Therefore we will add a function multiply to the general functions Add code In functions.general.py we add our new function: def multiply(gdf, left, right): \"\"\" Multiply 'left' with 'right' Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : str, numeric Right column or value in expression Returns ------- result : Series Float series \"\"\" expression = \" * \".join(map(str, [left, right])) return gdf.eval(expression) Please note the use of numpy docstrings . These are required as they are later translated to documentation. Also note we use GeoPandas GeoDataFrames specified by the input variable gdf . Please make your code fast and efficient by the use of in-build methods. Above we use gdf.eval(expression) by example. In complex cases you can use gdf.apply(lambda x: _a_function_for_every_row(row, *args, **kwargs), axis=1) to apply a function on every row in your GeoDataFrame. Here *args and **kwargs refer to extra input arguments. In functions.topologic.py and functions.logic.py you can find numerous examples. Test code In the test-folder we add a test. In this case we can add it to tests.general_functions_test.py : def test_multiply(): _gdf = gpd.GeoDataFrame(data={\"left\": [1, 2, 3], \"right\": [4, 5, 6], \"geometry\": [None, None, None]}) expected_result = [4, 10, 18] result = general_functions.multiply(_gdf, left=\"left\", right=\"right\").to_list() assert result == expected_result A test-function starts with test_ . In within the test-function you confirm if your new functionity is correct with assert = True . In this case we check if the result of our function is the same as our expected_result Within your activated environment you can test your function with pytest: pytest --cov-report term-missing --cov=hydamo_validation tests/ As your function is correct, the test should not fail. You can confirm all lines of your new code are tested: Contribute Commit First commit your new function in your own repository: Request a merge Now request a merge:","title":"Contribute"},{"location":"guides/contribute/#contribute","text":"For doing contributions you: have your own GitHub account work with GitHub Desktop or work-round with Git can work with GeoPandas and Pytest We are very happy with contributions that are: written similar to existing code (e.g. use of GeoPandas) provided with docstrings so it can be documented tested with Pytest You can make a contribution in the following steps: Development installation Fork and clone and install a copy Add and test new code Commit your copy and request a merge The remainder of this guide explains how to do it.","title":"Contribute"},{"location":"guides/contribute/#dev-installation","text":"","title":"Dev installation"},{"location":"guides/contribute/#setup-environment","text":"Use the env/dev_environment.yml in the repository to create the conda environment validatietool with all required packages conda env create -f dev_environment.yml After installation you can activate your environment in command prompt","title":"Setup environment"},{"location":"guides/contribute/#fork-repo","text":"Fork the respository to your own GitHub account: Click fork in the upper-right of the rository. Select your own github account The repository is now available on your own github account:","title":"Fork repo"},{"location":"guides/contribute/#clone-repo","text":"Now clone your fork to your local drive. We do this with GitHub Desktop . After installation and authentication you can get a local copy by: Add and Clone repository... in the top-left corner Find your fork and clone it to an empty directory on your local drive Press clone` Verify if the repository is on your local drive.","title":"Clone repo"},{"location":"guides/contribute/#install-copy","text":"Install the module in the activated validatietool environment in develop-mode: pip install -e . Now you're good to go!","title":"Install copy"},{"location":"guides/contribute/#improve-code","text":"Imagine we want to be able to multiply an HyDAMO attribute by a constant value or a value in an other attribute. Therefore we will add a function multiply to the general functions","title":"Improve code"},{"location":"guides/contribute/#add-code","text":"In functions.general.py we add our new function: def multiply(gdf, left, right): \"\"\" Multiply 'left' with 'right' Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : str, numeric Right column or value in expression Returns ------- result : Series Float series \"\"\" expression = \" * \".join(map(str, [left, right])) return gdf.eval(expression) Please note the use of numpy docstrings . These are required as they are later translated to documentation. Also note we use GeoPandas GeoDataFrames specified by the input variable gdf . Please make your code fast and efficient by the use of in-build methods. Above we use gdf.eval(expression) by example. In complex cases you can use gdf.apply(lambda x: _a_function_for_every_row(row, *args, **kwargs), axis=1) to apply a function on every row in your GeoDataFrame. Here *args and **kwargs refer to extra input arguments. In functions.topologic.py and functions.logic.py you can find numerous examples.","title":"Add code"},{"location":"guides/contribute/#test-code","text":"In the test-folder we add a test. In this case we can add it to tests.general_functions_test.py : def test_multiply(): _gdf = gpd.GeoDataFrame(data={\"left\": [1, 2, 3], \"right\": [4, 5, 6], \"geometry\": [None, None, None]}) expected_result = [4, 10, 18] result = general_functions.multiply(_gdf, left=\"left\", right=\"right\").to_list() assert result == expected_result A test-function starts with test_ . In within the test-function you confirm if your new functionity is correct with assert = True . In this case we check if the result of our function is the same as our expected_result Within your activated environment you can test your function with pytest: pytest --cov-report term-missing --cov=hydamo_validation tests/ As your function is correct, the test should not fail. You can confirm all lines of your new code are tested:","title":"Test code"},{"location":"guides/contribute/#contribute_1","text":"","title":"Contribute"},{"location":"guides/contribute/#commit","text":"First commit your new function in your own repository:","title":"Commit"},{"location":"guides/contribute/#request-a-merge","text":"Now request a merge:","title":"Request a merge"},{"location":"guides/get_started/","text":"Installation Install Anaconda or Miniconda Make sure you have an Miniconda or Anaconda installation. You can download these here: - https://www.anaconda.com/products/individual - https://docs.conda.io/en/latest/miniconda.html During installation, tick the box \"Add Anaconda to PATH\", ignore the red remarks Create the validatietool environment Use the env/environment.yml in the repository to create the conda environment: validatietool conda env create -f environment.yml After installation you can activate your environment in command prompt conda activate validatietool Install hydamo_validation Download or clone the repository. Now simply install the module in the activated environment: pip install . Run an example A working example with data can be found in notebooks/test_wrij.ipynb . In the activated environment launch jupyter notebook by: jupyter notebook Select test_wrij.ipynb read and run it.","title":"Get Started"},{"location":"guides/get_started/#installation","text":"","title":"Installation"},{"location":"guides/get_started/#install-anaconda-or-miniconda","text":"Make sure you have an Miniconda or Anaconda installation. You can download these here: - https://www.anaconda.com/products/individual - https://docs.conda.io/en/latest/miniconda.html During installation, tick the box \"Add Anaconda to PATH\", ignore the red remarks","title":"Install Anaconda or Miniconda"},{"location":"guides/get_started/#create-the-validatietool-environment","text":"Use the env/environment.yml in the repository to create the conda environment: validatietool conda env create -f environment.yml After installation you can activate your environment in command prompt conda activate validatietool","title":"Create the validatietool environment"},{"location":"guides/get_started/#install-hydamo_validation","text":"Download or clone the repository. Now simply install the module in the activated environment: pip install .","title":"Install hydamo_validation"},{"location":"guides/get_started/#run-an-example","text":"A working example with data can be found in notebooks/test_wrij.ipynb . In the activated environment launch jupyter notebook by: jupyter notebook Select test_wrij.ipynb read and run it.","title":"Run an example"},{"location":"reference/datasets/","text":"DataSets ValidationResult to be dumped as json. Source code in hydamo_validation\\datasets.py class DataSets : \"\"\"ValidationResult to be dumped as json.\"\"\" def __init__ ( self , dataset_dir : str ): \"\"\"Initialie datasets.\"\"\" self . path = Path ( dataset_dir ) self . properties = {} self . _set_properties () def _set_properties ( self ): dataset_files = self . path . glob ( \"*.gpkg\" ) for gpkg in dataset_files : layers = fiona . listlayers ( gpkg ) layers_dict = {} for layer in layers : with fiona . open ( gpkg , layer = layer ) as src : schema = normalize_fiona_schema ( src . schema ) layers_dict [ layer ] = schema self . properties [ gpkg . name ] = layers_dict def _filter_status ( self , gdf , status_object ): if status_object is not None : if \"statusobject\" in gdf . columns : # gdf = gdf.loc[gdf[\"statusobject\"].isin(status_object)] gdf = gdf . loc [ np . where ( gdf [ \"statusobject\" ] . isna () | gdf [ \"statusobject\" ] . isin ( status_object ) ) ] return gdf @property def layers ( self ): \"\"\"Return the layers in the datasets.\"\"\" dataset_layers_dict = { k : list ( v . keys ()) for k , v in self . properties . items ()} layers = [ item for sublist in list ( dataset_layers_dict . values ()) for item in sublist ] return layers def read_layer ( self , layer , result_summary = ResultSummary (), status_object = None ): \"\"\" Read a layer from the dataset. Parameters ---------- layer : str Name of the layer (case sensitive!) result_summary : ResultSummary A hydamo_validation ResultSummary class where a possible exception will be appended to. status_object : List[str], optional A list of statusobject values used as a filter. The default is None. Raises ------ e General exception while reading the layer from the geopackage. KeyError Specific exception; the layer is not part of the geopackage. Returns ------- gdf : GeoDataFrame GeoDataFrame read from datasets (all columns are converted to lower case) schema : TYPE Fiona schema read from the layer \"\"\" if layer in self . layers : dataset = { k : v for k , v in self . properties . items () if layer in v . keys ()} file_path = self . path . joinpath ( list ( dataset . keys ())[ 0 ]) schema = list ( dataset . values ())[ 0 ][ layer ] try : gdf = read_geopackage ( file_path , layer = layer ) gdf = self . _filter_status ( gdf , status_object ) except Exception as e : result_summary . append_warning ( ( f \"Laag { layer } uit bestand { file_path . name } is geen \" \"GeoPackage die wij kunnen openen. Vervang het bestand en \" \"probeer opnieuw.\" ) ) raise e # we will read all lower case schema [ \"properties\" ] = { k . lower (): v for k , v in schema [ \"properties\" ] . items () } gdf . columns = [ i . lower () for i in gdf . columns ] else : raise KeyError ( f \"' { layer } ' not in dataset-layers: ' { self . layers } '\" ) return gdf , schema layers property readonly Return the layers in the datasets. __init__ ( self , dataset_dir ) special Initialie datasets. Source code in hydamo_validation\\datasets.py def __init__ ( self , dataset_dir : str ): \"\"\"Initialie datasets.\"\"\" self . path = Path ( dataset_dir ) self . properties = {} self . _set_properties () read_layer ( self , layer , result_summary =< hydamo_validation . summaries . ResultSummary object at 0x00000215D6C357F0 > , status_object = None ) Read a layer from the dataset. Parameters layer : str Name of the layer (case sensitive!) result_summary : ResultSummary A hydamo_validation ResultSummary class where a possible exception will be appended to. status_object : List[str], optional A list of statusobject values used as a filter. The default is None. Raises e General exception while reading the layer from the geopackage. KeyError Specific exception; the layer is not part of the geopackage. Returns gdf : GeoDataFrame GeoDataFrame read from datasets (all columns are converted to lower case) schema : TYPE Fiona schema read from the layer Source code in hydamo_validation\\datasets.py def read_layer ( self , layer , result_summary = ResultSummary (), status_object = None ): \"\"\" Read a layer from the dataset. Parameters ---------- layer : str Name of the layer (case sensitive!) result_summary : ResultSummary A hydamo_validation ResultSummary class where a possible exception will be appended to. status_object : List[str], optional A list of statusobject values used as a filter. The default is None. Raises ------ e General exception while reading the layer from the geopackage. KeyError Specific exception; the layer is not part of the geopackage. Returns ------- gdf : GeoDataFrame GeoDataFrame read from datasets (all columns are converted to lower case) schema : TYPE Fiona schema read from the layer \"\"\" if layer in self . layers : dataset = { k : v for k , v in self . properties . items () if layer in v . keys ()} file_path = self . path . joinpath ( list ( dataset . keys ())[ 0 ]) schema = list ( dataset . values ())[ 0 ][ layer ] try : gdf = read_geopackage ( file_path , layer = layer ) gdf = self . _filter_status ( gdf , status_object ) except Exception as e : result_summary . append_warning ( ( f \"Laag { layer } uit bestand { file_path . name } is geen \" \"GeoPackage die wij kunnen openen. Vervang het bestand en \" \"probeer opnieuw.\" ) ) raise e # we will read all lower case schema [ \"properties\" ] = { k . lower (): v for k , v in schema [ \"properties\" ] . items () } gdf . columns = [ i . lower () for i in gdf . columns ] else : raise KeyError ( f \"' { layer } ' not in dataset-layers: ' { self . layers } '\" ) return gdf , schema","title":"DataSets"},{"location":"reference/datasets/#datasets","text":"ValidationResult to be dumped as json. Source code in hydamo_validation\\datasets.py class DataSets : \"\"\"ValidationResult to be dumped as json.\"\"\" def __init__ ( self , dataset_dir : str ): \"\"\"Initialie datasets.\"\"\" self . path = Path ( dataset_dir ) self . properties = {} self . _set_properties () def _set_properties ( self ): dataset_files = self . path . glob ( \"*.gpkg\" ) for gpkg in dataset_files : layers = fiona . listlayers ( gpkg ) layers_dict = {} for layer in layers : with fiona . open ( gpkg , layer = layer ) as src : schema = normalize_fiona_schema ( src . schema ) layers_dict [ layer ] = schema self . properties [ gpkg . name ] = layers_dict def _filter_status ( self , gdf , status_object ): if status_object is not None : if \"statusobject\" in gdf . columns : # gdf = gdf.loc[gdf[\"statusobject\"].isin(status_object)] gdf = gdf . loc [ np . where ( gdf [ \"statusobject\" ] . isna () | gdf [ \"statusobject\" ] . isin ( status_object ) ) ] return gdf @property def layers ( self ): \"\"\"Return the layers in the datasets.\"\"\" dataset_layers_dict = { k : list ( v . keys ()) for k , v in self . properties . items ()} layers = [ item for sublist in list ( dataset_layers_dict . values ()) for item in sublist ] return layers def read_layer ( self , layer , result_summary = ResultSummary (), status_object = None ): \"\"\" Read a layer from the dataset. Parameters ---------- layer : str Name of the layer (case sensitive!) result_summary : ResultSummary A hydamo_validation ResultSummary class where a possible exception will be appended to. status_object : List[str], optional A list of statusobject values used as a filter. The default is None. Raises ------ e General exception while reading the layer from the geopackage. KeyError Specific exception; the layer is not part of the geopackage. Returns ------- gdf : GeoDataFrame GeoDataFrame read from datasets (all columns are converted to lower case) schema : TYPE Fiona schema read from the layer \"\"\" if layer in self . layers : dataset = { k : v for k , v in self . properties . items () if layer in v . keys ()} file_path = self . path . joinpath ( list ( dataset . keys ())[ 0 ]) schema = list ( dataset . values ())[ 0 ][ layer ] try : gdf = read_geopackage ( file_path , layer = layer ) gdf = self . _filter_status ( gdf , status_object ) except Exception as e : result_summary . append_warning ( ( f \"Laag { layer } uit bestand { file_path . name } is geen \" \"GeoPackage die wij kunnen openen. Vervang het bestand en \" \"probeer opnieuw.\" ) ) raise e # we will read all lower case schema [ \"properties\" ] = { k . lower (): v for k , v in schema [ \"properties\" ] . items () } gdf . columns = [ i . lower () for i in gdf . columns ] else : raise KeyError ( f \"' { layer } ' not in dataset-layers: ' { self . layers } '\" ) return gdf , schema","title":"DataSets"},{"location":"reference/datasets/#hydamo_validation.datasets.DataSets.layers","text":"Return the layers in the datasets.","title":"layers"},{"location":"reference/datasets/#hydamo_validation.datasets.DataSets.__init__","text":"Initialie datasets. Source code in hydamo_validation\\datasets.py def __init__ ( self , dataset_dir : str ): \"\"\"Initialie datasets.\"\"\" self . path = Path ( dataset_dir ) self . properties = {} self . _set_properties ()","title":"__init__()"},{"location":"reference/datasets/#hydamo_validation.datasets.DataSets.read_layer","text":"Read a layer from the dataset.","title":"read_layer()"},{"location":"reference/datasets/#hydamo_validation.datasets.DataSets.read_layer--parameters","text":"layer : str Name of the layer (case sensitive!) result_summary : ResultSummary A hydamo_validation ResultSummary class where a possible exception will be appended to. status_object : List[str], optional A list of statusobject values used as a filter. The default is None.","title":"Parameters"},{"location":"reference/datasets/#hydamo_validation.datasets.DataSets.read_layer--raises","text":"e General exception while reading the layer from the geopackage. KeyError Specific exception; the layer is not part of the geopackage.","title":"Raises"},{"location":"reference/datasets/#hydamo_validation.datasets.DataSets.read_layer--returns","text":"gdf : GeoDataFrame GeoDataFrame read from datasets (all columns are converted to lower case) schema : TYPE Fiona schema read from the layer Source code in hydamo_validation\\datasets.py def read_layer ( self , layer , result_summary = ResultSummary (), status_object = None ): \"\"\" Read a layer from the dataset. Parameters ---------- layer : str Name of the layer (case sensitive!) result_summary : ResultSummary A hydamo_validation ResultSummary class where a possible exception will be appended to. status_object : List[str], optional A list of statusobject values used as a filter. The default is None. Raises ------ e General exception while reading the layer from the geopackage. KeyError Specific exception; the layer is not part of the geopackage. Returns ------- gdf : GeoDataFrame GeoDataFrame read from datasets (all columns are converted to lower case) schema : TYPE Fiona schema read from the layer \"\"\" if layer in self . layers : dataset = { k : v for k , v in self . properties . items () if layer in v . keys ()} file_path = self . path . joinpath ( list ( dataset . keys ())[ 0 ]) schema = list ( dataset . values ())[ 0 ][ layer ] try : gdf = read_geopackage ( file_path , layer = layer ) gdf = self . _filter_status ( gdf , status_object ) except Exception as e : result_summary . append_warning ( ( f \"Laag { layer } uit bestand { file_path . name } is geen \" \"GeoPackage die wij kunnen openen. Vervang het bestand en \" \"probeer opnieuw.\" ) ) raise e # we will read all lower case schema [ \"properties\" ] = { k . lower (): v for k , v in schema [ \"properties\" ] . items () } gdf . columns = [ i . lower () for i in gdf . columns ] else : raise KeyError ( f \"' { layer } ' not in dataset-layers: ' { self . layers } '\" ) return gdf , schema","title":"Returns"},{"location":"reference/general_functions/","text":"Topologic functions functions to be executed on gdf. buffer ( gdf , radius , percentile , coverage = 'ahn' , fill_value = None ) Percentile of coverage-value of an area defined by a radius around the object Parameters gdf : GeoDataFrame Input GeoDataFrame !!! radius \"str, numeric\" Radius around object used to define a cirular area percentile : int The percentile of the coverage within area around object coverage : str, optional The coverage to use. The default value is 'ahn' fill_value : float, optional The fill_value to use when the area is not intersecting the coverage. The default is None Returns result : Series Float series Source code in hydamo_validation\\functions\\general.py def buffer ( gdf , radius , percentile , coverage = \"ahn\" , fill_value : float = None ): \"\"\" Percentile of coverage-value of an area defined by a radius around the object Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame radius: str, numeric Radius around object used to define a cirular area percentile : int The percentile of the coverage within area around object coverage : str, optional The coverage to use. The default value is 'ahn' fill_value : float, optional The fill_value to use when the area is not intersecting the coverage. The default is None Returns ------- result : Series Float series \"\"\" gdf_out = gdf . copy () gdf_out [ \"result\" ] = np . nan xmin , ymin , xmax , ymax = gdf_out . total_bounds coverage_path = COVERAGES [ coverage ] index_gdf = gpd . read_file ( coverage_path . joinpath ( \"index.shp\" )) for idx , row in index_gdf . cx [ xmin : xmax , ymin : ymax ] . iterrows (): try : bathymetrie_raster = coverage_path . joinpath ( f ' { row [ \"bladnr\" ] . upper () } _CM.tif' ) gdf_select = gdf_out . loc [ gdf_out [ \"geometry\" ] . centroid . within ( row [ \"geometry\" ]) ] if not gdf_select . empty : if isinstance ( radius , str ): gdf_select . loc [:, ( \"geometry\" )] = gdf_select . apply ( _buffer_row , args = ( radius ,), axis = 1 ) else : radius = max ( radius , 0.5 ) gdf_select . loc [:, ( \"geometry\" )] = gdf_select [ \"geometry\" ] . buffer ( radius ) with rasterio . open ( bathymetrie_raster , \"r\" ) as src : profile = src . profile raster_data = src . read ( 1 ) affine = src . transform scale = src . scales [ 0 ] raster_stats = zonal_stats ( gdf_select , raster_data , affine = affine , stats = f \"percentile_ { percentile } \" , nodata = profile [ \"nodata\" ], raster_out = True , ) gdf_out . loc [ gdf_select . index . to_list (), \"result\" ] = [ np . nan if item is None else round ( item * scale , 2 ) for item in [ item [ f \"percentile_ { percentile } \" ] for item in raster_stats ] ] except Exception as e : print ( ( f \"bathymetrie: { bathymetrie_raster } \\n \" f \"indices: { gdf_select . index } \\n \" f \"geometrien: { gdf_select [ 'geometry' ] } \" ) ) raise e # fill series if if provided if fill_value is not None : gdf_out . loc [ gdf_out [ \"result\" ] . isna (), \"result\" ] = fill_value return gdf_out [ \"result\" ] difference ( gdf , left , right , absolute = False ) Difference between 'left' and 'right' Parameters gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression absolute : bool, optional Absolute (True) or relative difference (False) to left. The default is False. Returns result : Series Float series Source code in hydamo_validation\\functions\\general.py def difference ( gdf , left , right , absolute = False ): \"\"\" Difference between 'left' and 'right' Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression absolute : bool, optional Absolute (True) or relative difference (False) to left. The default is False. Returns ------- result : Series Float series \"\"\" if left in gdf . columns : left = gdf [ left ] if right in gdf . columns : right = gdf [ right ] if absolute : result = ( left - right ) . abs () else : result = left - right return result divide ( gdf , left , right ) Division of 'left' by 'right' Parameters gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression Returns result : Series Float series Source code in hydamo_validation\\functions\\general.py def divide ( gdf , left , right ): \"\"\" Division of 'left' by 'right' Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression Returns ------- result : Series Float series \"\"\" expression = \" / \" . join ( map ( str , [ left , right ])) return gdf . eval ( expression ) multiply ( gdf , left , right ) Multiply 'left' with 'right' Parameters gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : str, numeric Right column or value in expression Returns result : Series Float series Source code in hydamo_validation\\functions\\general.py def multiply ( gdf , left , right ): \"\"\" Multiply 'left' with 'right' Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : str, numeric Right column or value in expression Returns ------- result : Series Float series \"\"\" expression = \" * \" . join ( map ( str , [ left , right ])) return gdf . eval ( expression ) object_relation ( gdf , related_gdf , code_relation , statistic , related_parameter = None , fill_value = None ) Statistic of related object to geodataframe Parameters gdf : GeoDataFrame Input GeoDataFrame related_gdf : GeoDataFrame GeoDataFrame with related attributes code_relation : str Column in related_gdf used to relate to gdf. Example 'stuwid' statistic : str, options: 'min', 'max', 'sum', 'count' Statistic to compute over related values !!! related_parameter \"str\" Column in related_gdf over which the statistic is to be computed fill_value : float, optional The fill_value to use when the area is not intersecting the coverage. The default is None Returns result : Series Float series Source code in hydamo_validation\\functions\\general.py def object_relation ( gdf , related_gdf : gpd . GeoDataFrame , code_relation : str , statistic : Literal [ \"min\" , \"max\" , \"sum\" , \"count\" ], related_parameter : str = None , fill_value = None , ): \"\"\" Statistic of related object to geodataframe Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame related_gdf : GeoDataFrame GeoDataFrame with related attributes code_relation : str Column in related_gdf used to relate to gdf. Example 'stuwid' statistic : str, options: 'min', 'max', 'sum', 'count' Statistic to compute over related values related_parameter: str Column in related_gdf over which the statistic is to be computed fill_value : float, optional The fill_value to use when the area is not intersecting the coverage. The default is None Returns ------- result : Series Float series \"\"\" gdf_out = gdf . copy () # remove NaN values in from related_gdf[related_parameter] if related_parameter : if \"geometry\" in related_parameter : related_gdf [ related_parameter ] = _get_geometric_attribute ( related_gdf , related_parameter ) related_gdf = related_gdf . loc [ related_gdf [ related_parameter ] . notna ()] # compute statistic if statistic == \"count\" : series = related_gdf . groupby ( by = [ code_relation ])[ code_relation ] . count () elif statistic == \"sum\" : series = related_gdf . groupby ( by = [ code_relation ])[ related_parameter ] . sum () elif statistic == \"min\" : series = related_gdf . groupby ( by = [ code_relation ])[ related_parameter ] . min () elif statistic == \"max\" : series = related_gdf . groupby ( by = [ code_relation ])[ related_parameter ] . max () elif statistic == \"majority\" : series = related_gdf . groupby ( by = [ code_relation ])[ related_parameter ] . agg ( pd . Series . mode ) # join series with gdf series . name = \"result\" series = pd . DataFrame ( series . loc [ series . index . isin ( gdf [ \"globalid\" ])]) . reset_index () gdf_out = gdf_out . merge ( series , how = \"left\" , left_on = \"globalid\" , right_on = code_relation ) . set_index ( \"nen3610id\" ) # fill series if if provided if fill_value is not None : gdf_out . loc [ gdf_out [ \"result\" ] . isna (), \"result\" ] = fill_value return gdf_out [ \"result\" ] sum ( gdf , array ) Return a sum expression. Source code in hydamo_validation\\functions\\general.py def sum ( gdf , array : list ): \"\"\"Return a sum expression.\"\"\" expression = \" + \" . join ( map ( str , array )) return gdf . eval ( expression )","title":"General Functions"},{"location":"reference/general_functions/#topologic-functions","text":"functions to be executed on gdf.","title":"Topologic functions"},{"location":"reference/general_functions/#hydamo_validation.functions.general.general_functions.buffer","text":"Percentile of coverage-value of an area defined by a radius around the object","title":"buffer()"},{"location":"reference/general_functions/#hydamo_validation.functions.general.general_functions.buffer--parameters","text":"gdf : GeoDataFrame Input GeoDataFrame !!! radius \"str, numeric\" Radius around object used to define a cirular area percentile : int The percentile of the coverage within area around object coverage : str, optional The coverage to use. The default value is 'ahn' fill_value : float, optional The fill_value to use when the area is not intersecting the coverage. The default is None","title":"Parameters"},{"location":"reference/general_functions/#hydamo_validation.functions.general.general_functions.buffer--returns","text":"result : Series Float series Source code in hydamo_validation\\functions\\general.py def buffer ( gdf , radius , percentile , coverage = \"ahn\" , fill_value : float = None ): \"\"\" Percentile of coverage-value of an area defined by a radius around the object Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame radius: str, numeric Radius around object used to define a cirular area percentile : int The percentile of the coverage within area around object coverage : str, optional The coverage to use. The default value is 'ahn' fill_value : float, optional The fill_value to use when the area is not intersecting the coverage. The default is None Returns ------- result : Series Float series \"\"\" gdf_out = gdf . copy () gdf_out [ \"result\" ] = np . nan xmin , ymin , xmax , ymax = gdf_out . total_bounds coverage_path = COVERAGES [ coverage ] index_gdf = gpd . read_file ( coverage_path . joinpath ( \"index.shp\" )) for idx , row in index_gdf . cx [ xmin : xmax , ymin : ymax ] . iterrows (): try : bathymetrie_raster = coverage_path . joinpath ( f ' { row [ \"bladnr\" ] . upper () } _CM.tif' ) gdf_select = gdf_out . loc [ gdf_out [ \"geometry\" ] . centroid . within ( row [ \"geometry\" ]) ] if not gdf_select . empty : if isinstance ( radius , str ): gdf_select . loc [:, ( \"geometry\" )] = gdf_select . apply ( _buffer_row , args = ( radius ,), axis = 1 ) else : radius = max ( radius , 0.5 ) gdf_select . loc [:, ( \"geometry\" )] = gdf_select [ \"geometry\" ] . buffer ( radius ) with rasterio . open ( bathymetrie_raster , \"r\" ) as src : profile = src . profile raster_data = src . read ( 1 ) affine = src . transform scale = src . scales [ 0 ] raster_stats = zonal_stats ( gdf_select , raster_data , affine = affine , stats = f \"percentile_ { percentile } \" , nodata = profile [ \"nodata\" ], raster_out = True , ) gdf_out . loc [ gdf_select . index . to_list (), \"result\" ] = [ np . nan if item is None else round ( item * scale , 2 ) for item in [ item [ f \"percentile_ { percentile } \" ] for item in raster_stats ] ] except Exception as e : print ( ( f \"bathymetrie: { bathymetrie_raster } \\n \" f \"indices: { gdf_select . index } \\n \" f \"geometrien: { gdf_select [ 'geometry' ] } \" ) ) raise e # fill series if if provided if fill_value is not None : gdf_out . loc [ gdf_out [ \"result\" ] . isna (), \"result\" ] = fill_value return gdf_out [ \"result\" ]","title":"Returns"},{"location":"reference/general_functions/#hydamo_validation.functions.general.general_functions.difference","text":"Difference between 'left' and 'right'","title":"difference()"},{"location":"reference/general_functions/#hydamo_validation.functions.general.general_functions.difference--parameters","text":"gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression absolute : bool, optional Absolute (True) or relative difference (False) to left. The default is False.","title":"Parameters"},{"location":"reference/general_functions/#hydamo_validation.functions.general.general_functions.difference--returns","text":"result : Series Float series Source code in hydamo_validation\\functions\\general.py def difference ( gdf , left , right , absolute = False ): \"\"\" Difference between 'left' and 'right' Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression absolute : bool, optional Absolute (True) or relative difference (False) to left. The default is False. Returns ------- result : Series Float series \"\"\" if left in gdf . columns : left = gdf [ left ] if right in gdf . columns : right = gdf [ right ] if absolute : result = ( left - right ) . abs () else : result = left - right return result","title":"Returns"},{"location":"reference/general_functions/#hydamo_validation.functions.general.general_functions.divide","text":"Division of 'left' by 'right'","title":"divide()"},{"location":"reference/general_functions/#hydamo_validation.functions.general.general_functions.divide--parameters","text":"gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression","title":"Parameters"},{"location":"reference/general_functions/#hydamo_validation.functions.general.general_functions.divide--returns","text":"result : Series Float series Source code in hydamo_validation\\functions\\general.py def divide ( gdf , left , right ): \"\"\" Division of 'left' by 'right' Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression Returns ------- result : Series Float series \"\"\" expression = \" / \" . join ( map ( str , [ left , right ])) return gdf . eval ( expression )","title":"Returns"},{"location":"reference/general_functions/#hydamo_validation.functions.general.general_functions.multiply","text":"Multiply 'left' with 'right'","title":"multiply()"},{"location":"reference/general_functions/#hydamo_validation.functions.general.general_functions.multiply--parameters","text":"gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : str, numeric Right column or value in expression","title":"Parameters"},{"location":"reference/general_functions/#hydamo_validation.functions.general.general_functions.multiply--returns","text":"result : Series Float series Source code in hydamo_validation\\functions\\general.py def multiply ( gdf , left , right ): \"\"\" Multiply 'left' with 'right' Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : str, numeric Right column or value in expression Returns ------- result : Series Float series \"\"\" expression = \" * \" . join ( map ( str , [ left , right ])) return gdf . eval ( expression )","title":"Returns"},{"location":"reference/general_functions/#hydamo_validation.functions.general.general_functions.object_relation","text":"Statistic of related object to geodataframe","title":"object_relation()"},{"location":"reference/general_functions/#hydamo_validation.functions.general.general_functions.object_relation--parameters","text":"gdf : GeoDataFrame Input GeoDataFrame related_gdf : GeoDataFrame GeoDataFrame with related attributes code_relation : str Column in related_gdf used to relate to gdf. Example 'stuwid' statistic : str, options: 'min', 'max', 'sum', 'count' Statistic to compute over related values !!! related_parameter \"str\" Column in related_gdf over which the statistic is to be computed fill_value : float, optional The fill_value to use when the area is not intersecting the coverage. The default is None","title":"Parameters"},{"location":"reference/general_functions/#hydamo_validation.functions.general.general_functions.object_relation--returns","text":"result : Series Float series Source code in hydamo_validation\\functions\\general.py def object_relation ( gdf , related_gdf : gpd . GeoDataFrame , code_relation : str , statistic : Literal [ \"min\" , \"max\" , \"sum\" , \"count\" ], related_parameter : str = None , fill_value = None , ): \"\"\" Statistic of related object to geodataframe Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame related_gdf : GeoDataFrame GeoDataFrame with related attributes code_relation : str Column in related_gdf used to relate to gdf. Example 'stuwid' statistic : str, options: 'min', 'max', 'sum', 'count' Statistic to compute over related values related_parameter: str Column in related_gdf over which the statistic is to be computed fill_value : float, optional The fill_value to use when the area is not intersecting the coverage. The default is None Returns ------- result : Series Float series \"\"\" gdf_out = gdf . copy () # remove NaN values in from related_gdf[related_parameter] if related_parameter : if \"geometry\" in related_parameter : related_gdf [ related_parameter ] = _get_geometric_attribute ( related_gdf , related_parameter ) related_gdf = related_gdf . loc [ related_gdf [ related_parameter ] . notna ()] # compute statistic if statistic == \"count\" : series = related_gdf . groupby ( by = [ code_relation ])[ code_relation ] . count () elif statistic == \"sum\" : series = related_gdf . groupby ( by = [ code_relation ])[ related_parameter ] . sum () elif statistic == \"min\" : series = related_gdf . groupby ( by = [ code_relation ])[ related_parameter ] . min () elif statistic == \"max\" : series = related_gdf . groupby ( by = [ code_relation ])[ related_parameter ] . max () elif statistic == \"majority\" : series = related_gdf . groupby ( by = [ code_relation ])[ related_parameter ] . agg ( pd . Series . mode ) # join series with gdf series . name = \"result\" series = pd . DataFrame ( series . loc [ series . index . isin ( gdf [ \"globalid\" ])]) . reset_index () gdf_out = gdf_out . merge ( series , how = \"left\" , left_on = \"globalid\" , right_on = code_relation ) . set_index ( \"nen3610id\" ) # fill series if if provided if fill_value is not None : gdf_out . loc [ gdf_out [ \"result\" ] . isna (), \"result\" ] = fill_value return gdf_out [ \"result\" ]","title":"Returns"},{"location":"reference/general_functions/#hydamo_validation.functions.general.general_functions.sum","text":"Return a sum expression. Source code in hydamo_validation\\functions\\general.py def sum ( gdf , array : list ): \"\"\"Return a sum expression.\"\"\" expression = \" + \" . join ( map ( str , array )) return gdf . eval ( expression )","title":"sum()"},{"location":"reference/hydamo/","text":"HyDAMO datamodel Definition of the HyDAMO datamodel. Source code in hydamo_validation\\datamodel.py class HyDAMO : \"\"\"Definition of the HyDAMO datamodel.\"\"\" def __init__ ( self , version : str = \"2.2\" , schemas_path : Path = Path ( __file__ ) . parent . joinpath ( r \"./schemas\" ), ignored_layers : List = [ \"afvoeraanvoergebied\" , \"imwa_geoobject\" , \"leggerwatersysteem\" , \"leggerwaterveiligheid\" , \"waterbeheergebied\" , ], ): self . version = version self . schema_json = schemas_path . joinpath ( f \"hydamo/HyDAMO_ { version } .json\" ) self . layers = [] self . ignored_layers = ignored_layers self . init_datamodel () def init_datamodel ( self ): \"\"\"Initialize DataModel from self.schemas_path.\"\"\" self . validation_schemas : dict = {} # read schema as dict with open ( self . schema_json ) as src : schema = json . load ( src ) hydamo_layers = [ Path ( i [ \"$ref\" ]) . name for i in schema [ \"properties\" ][ \"HyDAMO\" ][ \"anyOf\" ] ] self . layers = [ i for i in hydamo_layers if not i in self . ignored_layers ] for hydamo_layer in self . layers : definition = schema [ \"definitions\" ][ hydamo_layer ][ \"properties\" ] layer_schema = map_definition ( definition ) self . validation_schemas [ hydamo_layer ] = layer_schema # add layer to data_model geotype = next ( ( i [ \"dtype\" ] for i in layer_schema if i [ \"id\" ] == \"geometry\" ), None ) required_columns = [ i [ \"id\" ] for i in [ i for i in layer_schema if \"required\" in i . keys ()] if i [ \"required\" ] ] setattr ( self , hydamo_layer , ExtendedGeoDataFrame ( validation_schema = layer_schema , geotype = geotype , required_columns = required_columns , ), ) def set_data ( self , gdf , layer , index_col = None , check_columns = True , check_geotype = True ): \"\"\" Parameters ---------- gdf : GeoDataFrame GeoDataFrame with a HyDAMO object-layer layer : TYPE HyDAMO layer to be set index_col : str, optional Column to be used as index. The default is None. check_columns : bool, optional Check if all required columns are present in the GeoDataFrame. The default is True. check_geotype : bool, optional Check if the geometry is of the required type. The default is True. Returns ------- None. \"\"\" getattr ( self , layer ) . set_data ( gdf , index_col = index_col , check_columns = check_columns , check_geotype = check_geotype , ) def to_geopackage ( self , file_path , use_schema = True ): \"\"\" Parameters ---------- file_path : path-string Path-string where the file should be written to use_schema : bool, optional Use the schema to specify column-properties The default is True. Returns ------- None. \"\"\" for layer in self . layers : gdf = getattr ( self , layer ) if not gdf . empty : if use_schema : # match fiona layer schema keys with gdf.columns schema = getattr ( self , layer ) . _get_schema () schema_cols = list ( schema [ \"properties\" ] . keys ()) + [ \"geometry\" ] drop_cols = [ i for i in gdf . columns if i not in schema_cols ] gdf_export = gdf . drop ( columns = drop_cols ) schema [ \"properties\" ] = { k : v for k , v in schema [ \"properties\" ] . items () if k in gdf_export . columns } # write gdf to geopackage, including schema if gdf_export . index . name in gdf_export . columns : export_gdf = gdf_export . reset_index ( drop = True ) . copy () export_gdf . to_file ( file_path , layer = layer , driver = \"GPKG\" , schema = schema , ) else : # write gdf to geopackage as is if gdf . index . name in gdf . columns : gdf = gdf . reset_index ( drop = True ) . copy () gdf . to_file ( file_path , layer = layer , driver = \"GPKG\" ) init_datamodel ( self ) Initialize DataModel from self.schemas_path. Source code in hydamo_validation\\datamodel.py def init_datamodel ( self ): \"\"\"Initialize DataModel from self.schemas_path.\"\"\" self . validation_schemas : dict = {} # read schema as dict with open ( self . schema_json ) as src : schema = json . load ( src ) hydamo_layers = [ Path ( i [ \"$ref\" ]) . name for i in schema [ \"properties\" ][ \"HyDAMO\" ][ \"anyOf\" ] ] self . layers = [ i for i in hydamo_layers if not i in self . ignored_layers ] for hydamo_layer in self . layers : definition = schema [ \"definitions\" ][ hydamo_layer ][ \"properties\" ] layer_schema = map_definition ( definition ) self . validation_schemas [ hydamo_layer ] = layer_schema # add layer to data_model geotype = next ( ( i [ \"dtype\" ] for i in layer_schema if i [ \"id\" ] == \"geometry\" ), None ) required_columns = [ i [ \"id\" ] for i in [ i for i in layer_schema if \"required\" in i . keys ()] if i [ \"required\" ] ] setattr ( self , hydamo_layer , ExtendedGeoDataFrame ( validation_schema = layer_schema , geotype = geotype , required_columns = required_columns , ), ) set_data ( self , gdf , layer , index_col = None , check_columns = True , check_geotype = True ) Parameters gdf : GeoDataFrame GeoDataFrame with a HyDAMO object-layer layer : TYPE HyDAMO layer to be set index_col : str, optional Column to be used as index. The default is None. check_columns : bool, optional Check if all required columns are present in the GeoDataFrame. The default is True. check_geotype : bool, optional Check if the geometry is of the required type. The default is True. Returns None. Source code in hydamo_validation\\datamodel.py def set_data ( self , gdf , layer , index_col = None , check_columns = True , check_geotype = True ): \"\"\" Parameters ---------- gdf : GeoDataFrame GeoDataFrame with a HyDAMO object-layer layer : TYPE HyDAMO layer to be set index_col : str, optional Column to be used as index. The default is None. check_columns : bool, optional Check if all required columns are present in the GeoDataFrame. The default is True. check_geotype : bool, optional Check if the geometry is of the required type. The default is True. Returns ------- None. \"\"\" getattr ( self , layer ) . set_data ( gdf , index_col = index_col , check_columns = check_columns , check_geotype = check_geotype , ) to_geopackage ( self , file_path , use_schema = True ) Parameters file_path : path-string Path-string where the file should be written to use_schema : bool, optional Use the schema to specify column-properties The default is True. Returns None. Source code in hydamo_validation\\datamodel.py def to_geopackage ( self , file_path , use_schema = True ): \"\"\" Parameters ---------- file_path : path-string Path-string where the file should be written to use_schema : bool, optional Use the schema to specify column-properties The default is True. Returns ------- None. \"\"\" for layer in self . layers : gdf = getattr ( self , layer ) if not gdf . empty : if use_schema : # match fiona layer schema keys with gdf.columns schema = getattr ( self , layer ) . _get_schema () schema_cols = list ( schema [ \"properties\" ] . keys ()) + [ \"geometry\" ] drop_cols = [ i for i in gdf . columns if i not in schema_cols ] gdf_export = gdf . drop ( columns = drop_cols ) schema [ \"properties\" ] = { k : v for k , v in schema [ \"properties\" ] . items () if k in gdf_export . columns } # write gdf to geopackage, including schema if gdf_export . index . name in gdf_export . columns : export_gdf = gdf_export . reset_index ( drop = True ) . copy () export_gdf . to_file ( file_path , layer = layer , driver = \"GPKG\" , schema = schema , ) else : # write gdf to geopackage as is if gdf . index . name in gdf . columns : gdf = gdf . reset_index ( drop = True ) . copy () gdf . to_file ( file_path , layer = layer , driver = \"GPKG\" )","title":"HyDAMO"},{"location":"reference/hydamo/#hydamo-datamodel","text":"Definition of the HyDAMO datamodel. Source code in hydamo_validation\\datamodel.py class HyDAMO : \"\"\"Definition of the HyDAMO datamodel.\"\"\" def __init__ ( self , version : str = \"2.2\" , schemas_path : Path = Path ( __file__ ) . parent . joinpath ( r \"./schemas\" ), ignored_layers : List = [ \"afvoeraanvoergebied\" , \"imwa_geoobject\" , \"leggerwatersysteem\" , \"leggerwaterveiligheid\" , \"waterbeheergebied\" , ], ): self . version = version self . schema_json = schemas_path . joinpath ( f \"hydamo/HyDAMO_ { version } .json\" ) self . layers = [] self . ignored_layers = ignored_layers self . init_datamodel () def init_datamodel ( self ): \"\"\"Initialize DataModel from self.schemas_path.\"\"\" self . validation_schemas : dict = {} # read schema as dict with open ( self . schema_json ) as src : schema = json . load ( src ) hydamo_layers = [ Path ( i [ \"$ref\" ]) . name for i in schema [ \"properties\" ][ \"HyDAMO\" ][ \"anyOf\" ] ] self . layers = [ i for i in hydamo_layers if not i in self . ignored_layers ] for hydamo_layer in self . layers : definition = schema [ \"definitions\" ][ hydamo_layer ][ \"properties\" ] layer_schema = map_definition ( definition ) self . validation_schemas [ hydamo_layer ] = layer_schema # add layer to data_model geotype = next ( ( i [ \"dtype\" ] for i in layer_schema if i [ \"id\" ] == \"geometry\" ), None ) required_columns = [ i [ \"id\" ] for i in [ i for i in layer_schema if \"required\" in i . keys ()] if i [ \"required\" ] ] setattr ( self , hydamo_layer , ExtendedGeoDataFrame ( validation_schema = layer_schema , geotype = geotype , required_columns = required_columns , ), ) def set_data ( self , gdf , layer , index_col = None , check_columns = True , check_geotype = True ): \"\"\" Parameters ---------- gdf : GeoDataFrame GeoDataFrame with a HyDAMO object-layer layer : TYPE HyDAMO layer to be set index_col : str, optional Column to be used as index. The default is None. check_columns : bool, optional Check if all required columns are present in the GeoDataFrame. The default is True. check_geotype : bool, optional Check if the geometry is of the required type. The default is True. Returns ------- None. \"\"\" getattr ( self , layer ) . set_data ( gdf , index_col = index_col , check_columns = check_columns , check_geotype = check_geotype , ) def to_geopackage ( self , file_path , use_schema = True ): \"\"\" Parameters ---------- file_path : path-string Path-string where the file should be written to use_schema : bool, optional Use the schema to specify column-properties The default is True. Returns ------- None. \"\"\" for layer in self . layers : gdf = getattr ( self , layer ) if not gdf . empty : if use_schema : # match fiona layer schema keys with gdf.columns schema = getattr ( self , layer ) . _get_schema () schema_cols = list ( schema [ \"properties\" ] . keys ()) + [ \"geometry\" ] drop_cols = [ i for i in gdf . columns if i not in schema_cols ] gdf_export = gdf . drop ( columns = drop_cols ) schema [ \"properties\" ] = { k : v for k , v in schema [ \"properties\" ] . items () if k in gdf_export . columns } # write gdf to geopackage, including schema if gdf_export . index . name in gdf_export . columns : export_gdf = gdf_export . reset_index ( drop = True ) . copy () export_gdf . to_file ( file_path , layer = layer , driver = \"GPKG\" , schema = schema , ) else : # write gdf to geopackage as is if gdf . index . name in gdf . columns : gdf = gdf . reset_index ( drop = True ) . copy () gdf . to_file ( file_path , layer = layer , driver = \"GPKG\" )","title":"HyDAMO datamodel"},{"location":"reference/hydamo/#hydamo_validation.datamodel.HyDAMO.init_datamodel","text":"Initialize DataModel from self.schemas_path. Source code in hydamo_validation\\datamodel.py def init_datamodel ( self ): \"\"\"Initialize DataModel from self.schemas_path.\"\"\" self . validation_schemas : dict = {} # read schema as dict with open ( self . schema_json ) as src : schema = json . load ( src ) hydamo_layers = [ Path ( i [ \"$ref\" ]) . name for i in schema [ \"properties\" ][ \"HyDAMO\" ][ \"anyOf\" ] ] self . layers = [ i for i in hydamo_layers if not i in self . ignored_layers ] for hydamo_layer in self . layers : definition = schema [ \"definitions\" ][ hydamo_layer ][ \"properties\" ] layer_schema = map_definition ( definition ) self . validation_schemas [ hydamo_layer ] = layer_schema # add layer to data_model geotype = next ( ( i [ \"dtype\" ] for i in layer_schema if i [ \"id\" ] == \"geometry\" ), None ) required_columns = [ i [ \"id\" ] for i in [ i for i in layer_schema if \"required\" in i . keys ()] if i [ \"required\" ] ] setattr ( self , hydamo_layer , ExtendedGeoDataFrame ( validation_schema = layer_schema , geotype = geotype , required_columns = required_columns , ), )","title":"init_datamodel()"},{"location":"reference/hydamo/#hydamo_validation.datamodel.HyDAMO.set_data","text":"","title":"set_data()"},{"location":"reference/hydamo/#hydamo_validation.datamodel.HyDAMO.set_data--parameters","text":"gdf : GeoDataFrame GeoDataFrame with a HyDAMO object-layer layer : TYPE HyDAMO layer to be set index_col : str, optional Column to be used as index. The default is None. check_columns : bool, optional Check if all required columns are present in the GeoDataFrame. The default is True. check_geotype : bool, optional Check if the geometry is of the required type. The default is True.","title":"Parameters"},{"location":"reference/hydamo/#hydamo_validation.datamodel.HyDAMO.set_data--returns","text":"None. Source code in hydamo_validation\\datamodel.py def set_data ( self , gdf , layer , index_col = None , check_columns = True , check_geotype = True ): \"\"\" Parameters ---------- gdf : GeoDataFrame GeoDataFrame with a HyDAMO object-layer layer : TYPE HyDAMO layer to be set index_col : str, optional Column to be used as index. The default is None. check_columns : bool, optional Check if all required columns are present in the GeoDataFrame. The default is True. check_geotype : bool, optional Check if the geometry is of the required type. The default is True. Returns ------- None. \"\"\" getattr ( self , layer ) . set_data ( gdf , index_col = index_col , check_columns = check_columns , check_geotype = check_geotype , )","title":"Returns"},{"location":"reference/hydamo/#hydamo_validation.datamodel.HyDAMO.to_geopackage","text":"","title":"to_geopackage()"},{"location":"reference/hydamo/#hydamo_validation.datamodel.HyDAMO.to_geopackage--parameters","text":"file_path : path-string Path-string where the file should be written to use_schema : bool, optional Use the schema to specify column-properties The default is True.","title":"Parameters"},{"location":"reference/hydamo/#hydamo_validation.datamodel.HyDAMO.to_geopackage--returns","text":"None. Source code in hydamo_validation\\datamodel.py def to_geopackage ( self , file_path , use_schema = True ): \"\"\" Parameters ---------- file_path : path-string Path-string where the file should be written to use_schema : bool, optional Use the schema to specify column-properties The default is True. Returns ------- None. \"\"\" for layer in self . layers : gdf = getattr ( self , layer ) if not gdf . empty : if use_schema : # match fiona layer schema keys with gdf.columns schema = getattr ( self , layer ) . _get_schema () schema_cols = list ( schema [ \"properties\" ] . keys ()) + [ \"geometry\" ] drop_cols = [ i for i in gdf . columns if i not in schema_cols ] gdf_export = gdf . drop ( columns = drop_cols ) schema [ \"properties\" ] = { k : v for k , v in schema [ \"properties\" ] . items () if k in gdf_export . columns } # write gdf to geopackage, including schema if gdf_export . index . name in gdf_export . columns : export_gdf = gdf_export . reset_index ( drop = True ) . copy () export_gdf . to_file ( file_path , layer = layer , driver = \"GPKG\" , schema = schema , ) else : # write gdf to geopackage as is if gdf . index . name in gdf . columns : gdf = gdf . reset_index ( drop = True ) . copy () gdf . to_file ( file_path , layer = layer , driver = \"GPKG\" )","title":"Returns"},{"location":"reference/logic_functions/","text":"Topologic functions Logic functions to be used in eval-method. BE ( gdf , parameter , min , max , inclusive = False ) Evaluate if parameter-value is between min/max inclusive (true/false) Parameters gdf : GeoDataFrame Input GeoDataFrame !!! parameter \"str\" Input column with numeric values min : numeric Lower limit of function max : numeric Upper limit of function inclusive : bool, optional To include min and max The default is False. Returns result : Series Pandas Series (default dtype = bool) Source code in hydamo_validation\\functions\\logic.py def BE ( gdf , parameter , min , max , inclusive = False ): \"\"\"Evaluate if parameter-value is between min/max inclusive (true/false) Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame parameter: str Input column with numeric values min : numeric Lower limit of function max : numeric Upper limit of function inclusive : bool, optional To include min and max The default is False. Returns ------- result : Series Pandas Series (default dtype = bool) \"\"\" if inclusive : series = GE ( gdf , parameter , min , dtype = bool ) & LE ( gdf , parameter , max , dtype = bool ) else : series = GT ( gdf , parameter , min , dtype = bool ) & LT ( gdf , parameter , max , dtype = bool ) return series EQ ( gdf , left , right , dtype =< class ' bool '>) Evalate if left an right expression are equal Parameters gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression dtype : dtype, optional dtype assigned to result Series The default is bool. Returns result : Series Pandas Series (default dtype = bool) Source code in hydamo_validation\\functions\\logic.py def EQ ( gdf , left , right , dtype = bool ): \"\"\"Evalate if left an right expression are equal Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression dtype : dtype, optional dtype assigned to result Series The default is bool. Returns ------- result : Series Pandas Series (default dtype = bool) \"\"\" expression = f \" { left } == { right } \" . lower () return gdf . eval ( expression ) . astype ( dtype ) GE ( gdf , left , right , dtype =< class ' bool '>) Evaluate if left is greater or equal to/than right Parameters gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression dtype : dtype, optional dtype assigned to result Series The default is bool. Returns result : Series Pandas Series (default dtype = bool) Source code in hydamo_validation\\functions\\logic.py def GE ( gdf , left , right , dtype = bool ): \"\"\"Evaluate if left is greater or equal to/than right Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression dtype : dtype, optional dtype assigned to result Series The default is bool. Returns ------- result : Series Pandas Series (default dtype = bool) \"\"\" expression = f \" { left } >= { right } \" . lower () return gdf . eval ( expression ) . astype ( dtype ) GT ( gdf , left , right , dtype =< class ' bool '>) Evaluate if left is greater than right Parameters gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression dtype : dtype, optional dtype assigned to result Series The default is bool. Returns result : Series Pandas Series (default dtype = bool) Source code in hydamo_validation\\functions\\logic.py def GT ( gdf , left , right , dtype = bool ): \"\"\" Evaluate if left is greater than right Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression dtype : dtype, optional dtype assigned to result Series The default is bool. Returns ------- result : Series Pandas Series (default dtype = bool) \"\"\" expression = f \" { left } > { right } \" . lower () return gdf . eval ( expression ) . astype ( dtype ) ISIN ( gdf , parameter , array ) Evaluate if values in parameter are in array Parameters gdf : GeoDataFrame Input GeoDataFrame !!! parameter \"str\" Input column with numeric values array : list list of possible values that return True Returns result : Series Pandas Series (default dtype = bool) Source code in hydamo_validation\\functions\\logic.py def ISIN ( gdf , parameter , array ): \"\"\"Evaluate if values in parameter are in array Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame parameter: str Input column with numeric values array : list list of possible values that return True Returns ------- result : Series Pandas Series (default dtype = bool) \"\"\" return gdf [ parameter ] . isin ( array ) LE ( gdf , left , right , dtype =< class ' bool '>) Evaluate if left is less or equal to/than right Parameters gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression dtype : dtype, optional dtype assigned to result Series The default is bool. Returns result : Series Pandas Series (default dtype = bool) Source code in hydamo_validation\\functions\\logic.py def LE ( gdf , left , right , dtype = bool ): \"\"\" Evaluate if left is less or equal to/than right Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression dtype : dtype, optional dtype assigned to result Series The default is bool. Returns ------- result : Series Pandas Series (default dtype = bool) \"\"\" expression = f \" { left } <= { right } \" . lower () return gdf . eval ( expression ) . astype ( dtype ) LT ( gdf , left , right , dtype =< class ' bool '>) Evaluate if left is less than right Parameters gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression dtype : dtype, optional dtype assigned to result Series The default is bool. Returns result : Series Pandas Series (default dtype = bool) Source code in hydamo_validation\\functions\\logic.py def LT ( gdf , left , right , dtype = bool ): \"\"\" Evaluate if left is less than right Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression dtype : dtype, optional dtype assigned to result Series The default is bool. Returns ------- result : Series Pandas Series (default dtype = bool) \"\"\" expression = f \" { left } < { right } \" . lower () return gdf . eval ( expression ) . astype ( dtype ) NOTIN ( gdf , parameter , array ) Evaluate if values in parameter are not in array Parameters gdf : GeoDataFrame Input GeoDataFrame !!! parameter \"str\" Input column with numeric values array : list list of possible values that return False Returns result : Series Pandas Series (default dtype = bool) Source code in hydamo_validation\\functions\\logic.py def NOTIN ( gdf , parameter , array ): \"\"\"Evaluate if values in parameter are not in array Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame parameter: str Input column with numeric values array : list list of possible values that return False Returns ------- result : Series Pandas Series (default dtype = bool) \"\"\" return ~ ISIN ( gdf , parameter , array )","title":"Logic Functions"},{"location":"reference/logic_functions/#topologic-functions","text":"Logic functions to be used in eval-method.","title":"Topologic functions"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.BE","text":"Evaluate if parameter-value is between min/max inclusive (true/false)","title":"BE()"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.BE--parameters","text":"gdf : GeoDataFrame Input GeoDataFrame !!! parameter \"str\" Input column with numeric values min : numeric Lower limit of function max : numeric Upper limit of function inclusive : bool, optional To include min and max The default is False.","title":"Parameters"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.BE--returns","text":"result : Series Pandas Series (default dtype = bool) Source code in hydamo_validation\\functions\\logic.py def BE ( gdf , parameter , min , max , inclusive = False ): \"\"\"Evaluate if parameter-value is between min/max inclusive (true/false) Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame parameter: str Input column with numeric values min : numeric Lower limit of function max : numeric Upper limit of function inclusive : bool, optional To include min and max The default is False. Returns ------- result : Series Pandas Series (default dtype = bool) \"\"\" if inclusive : series = GE ( gdf , parameter , min , dtype = bool ) & LE ( gdf , parameter , max , dtype = bool ) else : series = GT ( gdf , parameter , min , dtype = bool ) & LT ( gdf , parameter , max , dtype = bool ) return series","title":"Returns"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.EQ","text":"Evalate if left an right expression are equal","title":"EQ()"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.EQ--parameters","text":"gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression dtype : dtype, optional dtype assigned to result Series The default is bool.","title":"Parameters"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.EQ--returns","text":"result : Series Pandas Series (default dtype = bool) Source code in hydamo_validation\\functions\\logic.py def EQ ( gdf , left , right , dtype = bool ): \"\"\"Evalate if left an right expression are equal Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression dtype : dtype, optional dtype assigned to result Series The default is bool. Returns ------- result : Series Pandas Series (default dtype = bool) \"\"\" expression = f \" { left } == { right } \" . lower () return gdf . eval ( expression ) . astype ( dtype )","title":"Returns"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.GE","text":"Evaluate if left is greater or equal to/than right","title":"GE()"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.GE--parameters","text":"gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression dtype : dtype, optional dtype assigned to result Series The default is bool.","title":"Parameters"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.GE--returns","text":"result : Series Pandas Series (default dtype = bool) Source code in hydamo_validation\\functions\\logic.py def GE ( gdf , left , right , dtype = bool ): \"\"\"Evaluate if left is greater or equal to/than right Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression dtype : dtype, optional dtype assigned to result Series The default is bool. Returns ------- result : Series Pandas Series (default dtype = bool) \"\"\" expression = f \" { left } >= { right } \" . lower () return gdf . eval ( expression ) . astype ( dtype )","title":"Returns"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.GT","text":"Evaluate if left is greater than right","title":"GT()"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.GT--parameters","text":"gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression dtype : dtype, optional dtype assigned to result Series The default is bool.","title":"Parameters"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.GT--returns","text":"result : Series Pandas Series (default dtype = bool) Source code in hydamo_validation\\functions\\logic.py def GT ( gdf , left , right , dtype = bool ): \"\"\" Evaluate if left is greater than right Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression dtype : dtype, optional dtype assigned to result Series The default is bool. Returns ------- result : Series Pandas Series (default dtype = bool) \"\"\" expression = f \" { left } > { right } \" . lower () return gdf . eval ( expression ) . astype ( dtype )","title":"Returns"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.ISIN","text":"Evaluate if values in parameter are in array","title":"ISIN()"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.ISIN--parameters","text":"gdf : GeoDataFrame Input GeoDataFrame !!! parameter \"str\" Input column with numeric values array : list list of possible values that return True","title":"Parameters"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.ISIN--returns","text":"result : Series Pandas Series (default dtype = bool) Source code in hydamo_validation\\functions\\logic.py def ISIN ( gdf , parameter , array ): \"\"\"Evaluate if values in parameter are in array Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame parameter: str Input column with numeric values array : list list of possible values that return True Returns ------- result : Series Pandas Series (default dtype = bool) \"\"\" return gdf [ parameter ] . isin ( array )","title":"Returns"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.LE","text":"Evaluate if left is less or equal to/than right","title":"LE()"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.LE--parameters","text":"gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression dtype : dtype, optional dtype assigned to result Series The default is bool.","title":"Parameters"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.LE--returns","text":"result : Series Pandas Series (default dtype = bool) Source code in hydamo_validation\\functions\\logic.py def LE ( gdf , left , right , dtype = bool ): \"\"\" Evaluate if left is less or equal to/than right Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression dtype : dtype, optional dtype assigned to result Series The default is bool. Returns ------- result : Series Pandas Series (default dtype = bool) \"\"\" expression = f \" { left } <= { right } \" . lower () return gdf . eval ( expression ) . astype ( dtype )","title":"Returns"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.LT","text":"Evaluate if left is less than right","title":"LT()"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.LT--parameters","text":"gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression dtype : dtype, optional dtype assigned to result Series The default is bool.","title":"Parameters"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.LT--returns","text":"result : Series Pandas Series (default dtype = bool) Source code in hydamo_validation\\functions\\logic.py def LT ( gdf , left , right , dtype = bool ): \"\"\" Evaluate if left is less than right Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame left : str, numeric Left column or value in expression right : TYPE Right column or value in expression dtype : dtype, optional dtype assigned to result Series The default is bool. Returns ------- result : Series Pandas Series (default dtype = bool) \"\"\" expression = f \" { left } < { right } \" . lower () return gdf . eval ( expression ) . astype ( dtype )","title":"Returns"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.NOTIN","text":"Evaluate if values in parameter are not in array","title":"NOTIN()"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.NOTIN--parameters","text":"gdf : GeoDataFrame Input GeoDataFrame !!! parameter \"str\" Input column with numeric values array : list list of possible values that return False","title":"Parameters"},{"location":"reference/logic_functions/#hydamo_validation.functions.logic.logic_functions.NOTIN--returns","text":"result : Series Pandas Series (default dtype = bool) Source code in hydamo_validation\\functions\\logic.py def NOTIN ( gdf , parameter , array ): \"\"\"Evaluate if values in parameter are not in array Parameters ---------- gdf : GeoDataFrame Input GeoDataFrame parameter: str Input column with numeric values array : list list of possible values that return False Returns ------- result : Series Pandas Series (default dtype = bool) \"\"\" return ~ ISIN ( gdf , parameter , array )","title":"Returns"},{"location":"reference/topologic_functions/","text":"Topologic functions Topologic functions executed on extended geodataframe. distant_to_others ( gdf , datamodel , distance ) Check if two objects are sufficient distant to other objects of the same layer. Parameters gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class distance : numeric Max distance to other node Returns Pandas Series Default dtype is bool Source code in hydamo_validation\\functions\\topologic.py def distant_to_others ( gdf , datamodel , distance ): \"\"\" Check if two objects are sufficient distant to other objects of the same layer. Parameters ---------- gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class distance : numeric Max distance to other node Returns ------- Pandas Series Default dtype is bool \"\"\" sindex = gdf . sindex return gdf . apply ( lambda x : _distant_to_others ( x , gdf , sindex , distance ), axis = 1 ) geometry_length ( gdf , datamodel , length , statistic = 'min' , dtype =< class ' bool '>) Check if geometrie length is longer/shorter than a value Parameters gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, typically a layer in a HyDAMO datamodel class datamodel : HyDAMO HyDAMO datamodel class length : numeric Length to compare the geometry length to statistic : str, options: 'min', 'max' Use length as minimal or maximal length. Default is 'min' dtype : dtype, optional Dtype to assign to the result series. The default is bool. Returns Pandas Series Default dtype is bool Source code in hydamo_validation\\functions\\topologic.py def geometry_length ( gdf , datamodel , length , statistic : Literal [ \"min\" , \"max\" ] = \"min\" , dtype = bool ): \"\"\"Check if geometrie length is longer/shorter than a value Parameters ---------- gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, typically a layer in a HyDAMO datamodel class datamodel : HyDAMO HyDAMO datamodel class length : numeric Length to compare the geometry length to statistic : str, options: 'min', 'max' Use length as minimal or maximal length. Default is 'min' dtype : dtype, optional Dtype to assign to the result series. The default is bool. Returns ------- Pandas Series Default dtype is bool \"\"\" if statistic == \"min\" : series = gdf [ \"geometry\" ] . length >= length elif statistic == \"max\" : series = gdf [ \"geometry\" ] . length <= length return series . astype ( dtype ) no_dangling_node ( gdf , datamodel , tolerance ) Check if there are structures at intersections Parameters gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class tolerance : numeric Max tolerance to determine if nodes are connected Returns Pandas Series Default dtype is bool Source code in hydamo_validation\\functions\\topologic.py def no_dangling_node ( gdf , datamodel , tolerance ): \"\"\"Check if there are structures at intersections Parameters ---------- gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class tolerance : numeric Max tolerance to determine if nodes are connected Returns ------- Pandas Series Default dtype is bool \"\"\" end_nodes_series = gdf [ \"geometry\" ] . apply ( lambda x : Point ( x . coords [ - 1 ])) series = gdf [ \"geometry\" ] . apply ( lambda x : Point ( x . coords [ 0 ])) sindex = series . sindex return end_nodes_series . apply ( lambda x : _intersects_end_node ( x , series , sindex , tolerance ) ) not_overlapping ( gdf , datamodel , tolerance ) Check if geometrie length is longer/shorter than a value Parameters gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, typically a layer in a HyDAMO datamodel class datamodel : HyDAMO HyDAMO datamodel class tolerance : numeric Max tolerance for overlapping Returns Pandas Series Default dtype is bool Source code in hydamo_validation\\functions\\topologic.py def not_overlapping ( gdf , datamodel , tolerance ): \"\"\"Check if geometrie length is longer/shorter than a value Parameters ---------- gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, typically a layer in a HyDAMO datamodel class datamodel : HyDAMO HyDAMO datamodel class tolerance : numeric Max tolerance for overlapping Returns ------- Pandas Series Default dtype is bool \"\"\" sindex = gdf . sindex return gdf . apply ( lambda x : _not_overlapping_line ( x , gdf , sindex , tolerance ), axis = 1 ) snaps_to_hydroobject ( gdf , datamodel , method , tolerance = 0.001 , dtype =< class ' bool '>) Check if geometries snap to HydroObject Parameters gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, typically a layer in a HyDAMO datamodel class datamodel : HyDAMO HyDAMO datamodel class method : str, options: 'intersecting', 'overal', 'centroid', 'ends' Method that can be used to deterine nearest hydrobject tolerance : numeric Tolerance used to snap to the hydroobjct dtype : dtype, optional Dtype to assign to the result series. The default is bool. Returns Pandas Series Default dtype is bool Source code in hydamo_validation\\functions\\topologic.py def snaps_to_hydroobject ( gdf , datamodel , method , tolerance = 0.001 , dtype = bool ): \"\"\" Check if geometries snap to HydroObject Parameters ---------- gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, typically a layer in a HyDAMO datamodel class datamodel : HyDAMO HyDAMO datamodel class method : str, options: 'intersecting', 'overal', 'centroid', 'ends' Method that can be used to deterine nearest hydrobject tolerance : numeric Tolerance used to snap to the hydroobjct dtype : dtype, optional Dtype to assign to the result series. The default is bool. Returns ------- Pandas Series Default dtype is bool \"\"\" branches = datamodel . hydroobject gdf . snap_to_branch ( branches , snap_method = method , maxdist = tolerance ) series = ~ gdf . branch_offset . isna () return series . astype ( dtype ) splitted_at_junction ( gdf , datamodel , tolerance ) Check if line is splitted when it can considered to be a junction Parameters gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class tolerance : numeric Max tolerance for junction nodes Returns Pandas Series Default dtype is bool Source code in hydamo_validation\\functions\\topologic.py def splitted_at_junction ( gdf , datamodel , tolerance ): \"\"\"Check if line is splitted when it can considered to be a junction Parameters ---------- gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class tolerance : numeric Max tolerance for junction nodes Returns ------- Pandas Series Default dtype is bool \"\"\" # get the nodes of the hydroobjects within tolerance nodes_series = _get_nodes ( gdf , tolerance ) # check for lines if there are nodes on segment outside tolerance of # the start-node and end-node. sindex = nodes_series . sindex return gdf [ \"geometry\" ] . apply ( lambda x : _only_end_nodes ( x , nodes_series , sindex , tolerance ) ) structures_at_boundaries ( gdf , datamodel , areas , structures , tolerance , distance ) Check if there are structures near area (typically water-level areas) boundaries. Parameters gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class areas : str HyDAMO datamodel class with areas (\"peilgebiedenpraktijk\") structures : str List with structure-types to be expected on the boundary tolerance : numeric Tolerance to dermine if a structure is on the hydroobject distance : numeric Max distance between structure and area-boundary Returns Pandas Series Default dtype is bool Source code in hydamo_validation\\functions\\topologic.py def structures_at_boundaries ( gdf , datamodel , areas , structures , tolerance , distance ): \"\"\" Check if there are structures near area (typically water-level areas) boundaries. Parameters ---------- gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class areas : str HyDAMO datamodel class with areas (\"peilgebiedenpraktijk\") structures : str List with structure-types to be expected on the boundary tolerance : numeric Tolerance to dermine if a structure is on the hydroobject distance : numeric Max distance between structure and area-boundary Returns ------- Pandas Series Default dtype is bool \"\"\" areas_gdf = getattr ( datamodel , areas ) areas_sindex = areas_gdf . sindex struc_series = _layers_from_datamodel ( structures , datamodel ) struc_sindex = struc_series . sindex return gdf . apply ( lambda x : _structures_at_boundaries ( x , areas_gdf , areas_sindex , struc_series , struc_sindex , tolerance , distance ), axis = 1 , ) structures_at_intersections ( gdf , datamodel , structures , tolerance ) Check if there are structures at intersections Parameters gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class !!! structures \"str or list\" HyDAMO structures to be expected at intersections (\"stuw\", \"duikersifonhevel\") Presented as a string or list tolerance : numeric Max tolerance for junction nodes Returns Pandas Series Default dtype is bool Source code in hydamo_validation\\functions\\topologic.py def structures_at_intersections ( gdf , datamodel , structures , tolerance ): \"\"\"Check if there are structures at intersections Parameters ---------- gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class structures: str or list HyDAMO structures to be expected at intersections (\"stuw\", \"duikersifonhevel\") Presented as a string or list tolerance : numeric Max tolerance for junction nodes Returns ------- Pandas Series Default dtype is bool \"\"\" # make a geodataframe from structures list struc_series = _layers_from_datamodel ( structures , datamodel ) # create spatial indices sindex = gdf . sindex struc_sindex = struc_series . sindex # return result return gdf . apply ( lambda x : _structures_at_intersections ( x , gdf , sindex , struc_series , struc_sindex , tolerance ), axis = 1 , ) structures_at_nodes ( gdf , datamodel , structures , tolerance ) Check if structures are on boundary-nodes of lines (hydroobjects) Parameters gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class structures : str List with structure-types to be expected on the boundary tolerance : numeric Tolerance to determine if a structure is on a node Returns Pandas Series Default dtype is bool Source code in hydamo_validation\\functions\\topologic.py def structures_at_nodes ( gdf , datamodel , structures , tolerance ): \"\"\" Check if structures are on boundary-nodes of lines (hydroobjects) Parameters ---------- gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class structures : str List with structure-types to be expected on the boundary tolerance : numeric Tolerance to determine if a structure is on a node Returns ------- Pandas Series Default dtype is bool \"\"\" struc_series = _layers_from_datamodel ( structures , datamodel ) struc_sindex = struc_series . sindex return gdf [ \"geometry\" ] . apply ( lambda x : _no_struc_on_line ( x , struc_series , struc_sindex , tolerance ) )","title":"Topologic Functions"},{"location":"reference/topologic_functions/#topologic-functions","text":"Topologic functions executed on extended geodataframe.","title":"Topologic functions"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.distant_to_others","text":"Check if two objects are sufficient distant to other objects of the same layer.","title":"distant_to_others()"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.distant_to_others--parameters","text":"gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class distance : numeric Max distance to other node","title":"Parameters"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.distant_to_others--returns","text":"Pandas Series Default dtype is bool Source code in hydamo_validation\\functions\\topologic.py def distant_to_others ( gdf , datamodel , distance ): \"\"\" Check if two objects are sufficient distant to other objects of the same layer. Parameters ---------- gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class distance : numeric Max distance to other node Returns ------- Pandas Series Default dtype is bool \"\"\" sindex = gdf . sindex return gdf . apply ( lambda x : _distant_to_others ( x , gdf , sindex , distance ), axis = 1 )","title":"Returns"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.geometry_length","text":"Check if geometrie length is longer/shorter than a value","title":"geometry_length()"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.geometry_length--parameters","text":"gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, typically a layer in a HyDAMO datamodel class datamodel : HyDAMO HyDAMO datamodel class length : numeric Length to compare the geometry length to statistic : str, options: 'min', 'max' Use length as minimal or maximal length. Default is 'min' dtype : dtype, optional Dtype to assign to the result series. The default is bool.","title":"Parameters"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.geometry_length--returns","text":"Pandas Series Default dtype is bool Source code in hydamo_validation\\functions\\topologic.py def geometry_length ( gdf , datamodel , length , statistic : Literal [ \"min\" , \"max\" ] = \"min\" , dtype = bool ): \"\"\"Check if geometrie length is longer/shorter than a value Parameters ---------- gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, typically a layer in a HyDAMO datamodel class datamodel : HyDAMO HyDAMO datamodel class length : numeric Length to compare the geometry length to statistic : str, options: 'min', 'max' Use length as minimal or maximal length. Default is 'min' dtype : dtype, optional Dtype to assign to the result series. The default is bool. Returns ------- Pandas Series Default dtype is bool \"\"\" if statistic == \"min\" : series = gdf [ \"geometry\" ] . length >= length elif statistic == \"max\" : series = gdf [ \"geometry\" ] . length <= length return series . astype ( dtype )","title":"Returns"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.no_dangling_node","text":"Check if there are structures at intersections","title":"no_dangling_node()"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.no_dangling_node--parameters","text":"gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class tolerance : numeric Max tolerance to determine if nodes are connected","title":"Parameters"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.no_dangling_node--returns","text":"Pandas Series Default dtype is bool Source code in hydamo_validation\\functions\\topologic.py def no_dangling_node ( gdf , datamodel , tolerance ): \"\"\"Check if there are structures at intersections Parameters ---------- gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class tolerance : numeric Max tolerance to determine if nodes are connected Returns ------- Pandas Series Default dtype is bool \"\"\" end_nodes_series = gdf [ \"geometry\" ] . apply ( lambda x : Point ( x . coords [ - 1 ])) series = gdf [ \"geometry\" ] . apply ( lambda x : Point ( x . coords [ 0 ])) sindex = series . sindex return end_nodes_series . apply ( lambda x : _intersects_end_node ( x , series , sindex , tolerance ) )","title":"Returns"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.not_overlapping","text":"Check if geometrie length is longer/shorter than a value","title":"not_overlapping()"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.not_overlapping--parameters","text":"gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, typically a layer in a HyDAMO datamodel class datamodel : HyDAMO HyDAMO datamodel class tolerance : numeric Max tolerance for overlapping","title":"Parameters"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.not_overlapping--returns","text":"Pandas Series Default dtype is bool Source code in hydamo_validation\\functions\\topologic.py def not_overlapping ( gdf , datamodel , tolerance ): \"\"\"Check if geometrie length is longer/shorter than a value Parameters ---------- gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, typically a layer in a HyDAMO datamodel class datamodel : HyDAMO HyDAMO datamodel class tolerance : numeric Max tolerance for overlapping Returns ------- Pandas Series Default dtype is bool \"\"\" sindex = gdf . sindex return gdf . apply ( lambda x : _not_overlapping_line ( x , gdf , sindex , tolerance ), axis = 1 )","title":"Returns"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.snaps_to_hydroobject","text":"Check if geometries snap to HydroObject","title":"snaps_to_hydroobject()"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.snaps_to_hydroobject--parameters","text":"gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, typically a layer in a HyDAMO datamodel class datamodel : HyDAMO HyDAMO datamodel class method : str, options: 'intersecting', 'overal', 'centroid', 'ends' Method that can be used to deterine nearest hydrobject tolerance : numeric Tolerance used to snap to the hydroobjct dtype : dtype, optional Dtype to assign to the result series. The default is bool.","title":"Parameters"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.snaps_to_hydroobject--returns","text":"Pandas Series Default dtype is bool Source code in hydamo_validation\\functions\\topologic.py def snaps_to_hydroobject ( gdf , datamodel , method , tolerance = 0.001 , dtype = bool ): \"\"\" Check if geometries snap to HydroObject Parameters ---------- gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, typically a layer in a HyDAMO datamodel class datamodel : HyDAMO HyDAMO datamodel class method : str, options: 'intersecting', 'overal', 'centroid', 'ends' Method that can be used to deterine nearest hydrobject tolerance : numeric Tolerance used to snap to the hydroobjct dtype : dtype, optional Dtype to assign to the result series. The default is bool. Returns ------- Pandas Series Default dtype is bool \"\"\" branches = datamodel . hydroobject gdf . snap_to_branch ( branches , snap_method = method , maxdist = tolerance ) series = ~ gdf . branch_offset . isna () return series . astype ( dtype )","title":"Returns"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.splitted_at_junction","text":"Check if line is splitted when it can considered to be a junction","title":"splitted_at_junction()"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.splitted_at_junction--parameters","text":"gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class tolerance : numeric Max tolerance for junction nodes","title":"Parameters"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.splitted_at_junction--returns","text":"Pandas Series Default dtype is bool Source code in hydamo_validation\\functions\\topologic.py def splitted_at_junction ( gdf , datamodel , tolerance ): \"\"\"Check if line is splitted when it can considered to be a junction Parameters ---------- gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class tolerance : numeric Max tolerance for junction nodes Returns ------- Pandas Series Default dtype is bool \"\"\" # get the nodes of the hydroobjects within tolerance nodes_series = _get_nodes ( gdf , tolerance ) # check for lines if there are nodes on segment outside tolerance of # the start-node and end-node. sindex = nodes_series . sindex return gdf [ \"geometry\" ] . apply ( lambda x : _only_end_nodes ( x , nodes_series , sindex , tolerance ) )","title":"Returns"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.structures_at_boundaries","text":"Check if there are structures near area (typically water-level areas) boundaries.","title":"structures_at_boundaries()"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.structures_at_boundaries--parameters","text":"gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class areas : str HyDAMO datamodel class with areas (\"peilgebiedenpraktijk\") structures : str List with structure-types to be expected on the boundary tolerance : numeric Tolerance to dermine if a structure is on the hydroobject distance : numeric Max distance between structure and area-boundary","title":"Parameters"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.structures_at_boundaries--returns","text":"Pandas Series Default dtype is bool Source code in hydamo_validation\\functions\\topologic.py def structures_at_boundaries ( gdf , datamodel , areas , structures , tolerance , distance ): \"\"\" Check if there are structures near area (typically water-level areas) boundaries. Parameters ---------- gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class areas : str HyDAMO datamodel class with areas (\"peilgebiedenpraktijk\") structures : str List with structure-types to be expected on the boundary tolerance : numeric Tolerance to dermine if a structure is on the hydroobject distance : numeric Max distance between structure and area-boundary Returns ------- Pandas Series Default dtype is bool \"\"\" areas_gdf = getattr ( datamodel , areas ) areas_sindex = areas_gdf . sindex struc_series = _layers_from_datamodel ( structures , datamodel ) struc_sindex = struc_series . sindex return gdf . apply ( lambda x : _structures_at_boundaries ( x , areas_gdf , areas_sindex , struc_series , struc_sindex , tolerance , distance ), axis = 1 , )","title":"Returns"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.structures_at_intersections","text":"Check if there are structures at intersections","title":"structures_at_intersections()"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.structures_at_intersections--parameters","text":"gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class !!! structures \"str or list\" HyDAMO structures to be expected at intersections (\"stuw\", \"duikersifonhevel\") Presented as a string or list tolerance : numeric Max tolerance for junction nodes","title":"Parameters"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.structures_at_intersections--returns","text":"Pandas Series Default dtype is bool Source code in hydamo_validation\\functions\\topologic.py def structures_at_intersections ( gdf , datamodel , structures , tolerance ): \"\"\"Check if there are structures at intersections Parameters ---------- gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class structures: str or list HyDAMO structures to be expected at intersections (\"stuw\", \"duikersifonhevel\") Presented as a string or list tolerance : numeric Max tolerance for junction nodes Returns ------- Pandas Series Default dtype is bool \"\"\" # make a geodataframe from structures list struc_series = _layers_from_datamodel ( structures , datamodel ) # create spatial indices sindex = gdf . sindex struc_sindex = struc_series . sindex # return result return gdf . apply ( lambda x : _structures_at_intersections ( x , gdf , sindex , struc_series , struc_sindex , tolerance ), axis = 1 , )","title":"Returns"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.structures_at_nodes","text":"Check if structures are on boundary-nodes of lines (hydroobjects)","title":"structures_at_nodes()"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.structures_at_nodes--parameters","text":"gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class structures : str List with structure-types to be expected on the boundary tolerance : numeric Tolerance to determine if a structure is on a node","title":"Parameters"},{"location":"reference/topologic_functions/#hydamo_validation.functions.topologic.topologic_functions.structures_at_nodes--returns","text":"Pandas Series Default dtype is bool Source code in hydamo_validation\\functions\\topologic.py def structures_at_nodes ( gdf , datamodel , structures , tolerance ): \"\"\" Check if structures are on boundary-nodes of lines (hydroobjects) Parameters ---------- gdf : ExtendedGeoDataframe ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO HyDAMO datamodel class structures : str List with structure-types to be expected on the boundary tolerance : numeric Tolerance to determine if a structure is on a node Returns ------- Pandas Series Default dtype is bool \"\"\" struc_series = _layers_from_datamodel ( structures , datamodel ) struc_sindex = struc_series . sindex return gdf [ \"geometry\" ] . apply ( lambda x : _no_struc_on_line ( x , struc_series , struc_sindex , tolerance ) )","title":"Returns"}]}